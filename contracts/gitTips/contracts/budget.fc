#include "imports/stdlib.fc";
#include "errors.fc";
#include "utils/utils.fc";
#include "op-codes.fc";

() save_data(int fee_rate, slice admin_addr, slice owner_addr) impure inline {
    set_data(begin_cell()
        .store_slice(admin_addr)    ;; admin_addr:MsgAddress
        .store_slice(owner_addr)    ;; owner_addr:MsgAddress
    .end_cell());
}

(int, slice, slice) load_data() impure inline {
    slice ds = get_data().begin_parse();

    return (
        ds~load_msg_addr(), ;; admin_address:MsgAddress
        ds~load_msg_addr()  ;; owner_addr:MsgAddress
    );
}

() withdraw(int amount, slice to_address, int sender_address_hash) impure {
    (_, slice admin_addr, slice owner_addr) = load_data();

    (_, int admin_address_hash) = parse_std_addr(admin_addr);
    (_, int owner_address_hash) = parse_std_addr(owner_addr);

    var budget_balance = get_balance().pair_first();

    throw_if(error::access_denied, admin_address_hash != sender_address_hash);

    (_, int to_address_hash) = parse_std_addr(to_address);

    ;; budget balance must not be less than withdrawal value
    throw_if(error::not_enough_budget_balance, amount);

    ;; budget can be withdrawed only to the owner address
    throw_if(error::access_denied, owner_address_hash != to_address_hash);

    cell msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(to_address)
                    .store_coins(amount)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .end_cell();

    ;; send mode - 1 to pay transfer fees separately and revert on errors.
    send_raw_message(msg, 1);

    return ();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4); ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool

    if (flags & 1) {
        return ();  ;; ignore all bounced messages
    }

    if (in_msg_body.slice_empty?()) {
        return ();  ;; ignore empty messages
    }

    (int op, int query_id) = in_msg_body~load_body_header(); ;; body_header:int_msg_info$10 query_id:uint64 op:uint32

    if (op == op::add_budget) {
        ;; recieve coins and do nothing
        return ();
    }

    if (op == op::withdraw_budget) {
        slice sender_address = cs~load_msg_addr();                      ;; sender:MsgAddress
        (_, int sender_address_hash) = parse_std_addr(sender_address);  ;; sender_addr_hash:uint256

        int amount = in_msg_body~load_coins();

        withdraw(amount, sender_address, sender_address_hash);
    }

    if (op == op::send_payout) {
        ;; TODO: load fee address and fee amount

        slice reciever_address = cs~load_msg_addr();                      ;; sender:MsgAddress
        (_, int reciever_address_hash) = parse_std_addr(reciever_address);  ;; sender_addr_hash:uint256

        slice sender_address = cs~load_msg_addr();                      ;; sender:MsgAddress
        (_, int sender_address_hash) = parse_std_addr(sender_address);  ;; sender_addr_hash:uint256

        slice to_address = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();

        withdraw(amount, reciever_address, sender_address_hash);

        ;; TODO: send fee to the fee address
    }

    throw(0xffff);
}